<!DOCTYPE html>
<html>
<head>
    <title>Milestone Burnup with Projection</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /**
 * @param {Array} data Array of objects returned by Store object
 * @param {Array} columns If present, returns values only for specified columns, in the provided order. If value is an object, use dot notation to access its property.
 * @returns {string} Lines of tab-separated values
 */
function storeDataToString(data, columns) {
    if (!data || !data[0] || !data[0].raw) {
        return "No data to display: " + data;
    }
    var actualColumns = columns || Object.keys(data[0].raw);
    var keys = actualColumns.map(function (column) {
        return column.split('.');
    });
    return data.reduce(function (result, row) {
        result.push(keys.map(function (key) {
            var value = row.raw[key[0]];
            return "" + value == "[object Object]" && key[1] ? value[key[1]] : value;
        }).join('\t'));
        return result;
    }, [actualColumns.join('\t') + '\t' + data.length]).join('\n');
}

function resolvedPromise(value) {
    return Deft.promise.Promise.when(value);
}

function rejectedPromise(error) {
    var deferred = Ext.create("Deft.Deferred");
    deferred.reject(error);
    return deferred.promise;
}

function promiseAll(array) {
    return array.length === 0 ? [] : Deft.Promise.all(array);
}


function collectIds(objects) {
    return objects.map(function (object) {
        return +object.raw.ObjectID;
    });
}

function getRallyRecordType(record) {
    return record && record.getData()._type;
}

function getRallyIdFromRef(ref, type) {
    return +ref.slice(type.length + 2);
}

function milestoneIcon(milestone) {
    return "<span class='artifact-icon icon-milestone' style='transform:rotate(20deg);color: " + milestone.get("DisplayColor") + ";'></span>";
}

function formatMilestone(milestone, context) {
    return milestoneIcon(milestone) + "<a target='_blank' style='color:#274b6d' href='" + getMilestoneUrl(milestone, context) + "'>" + milestone.get("Name") + "</a>";
}

function getMilestoneUrl(milestone, context) {
    return "https://rally1.rallydev.com/#/" + context.getProject().ObjectID + "d/detail" + milestone.getUri();
}

function formatProject(project, page) {
    return page ? "<a target='_blank' style='color:#274b6d' href='https://rally1.rallydev.com/#/" + project.get("ObjectID") + "d/" + page + "'>" + project.get("Name") + "</a>"
        : project.get("Name");
}

function formatPortfolioItem(portfolioItem, context) {
    return "<a target='_blank' style='color:#274b6d' href='" + getPortfolioItemUrl(portfolioItem, context) + "'><strong style='font-size:0.95em'>" +
        portfolioItem.get("FormattedID") + "</strong> " + portfolioItem.get("Name") + "</a>";
}

function getPortfolioItemUrl(portfolioItem, context) {
    return "https://rally1.rallydev.com/#/" + context.getProject().ObjectID + "d/detail" + portfolioItem.getUri();
}

function hasOwnProperties(object, minNumber) {
    minNumber = minNumber ? minNumber : 1;
    for (var property in object) {
        if (object.hasOwnProperty(property)) {
            if (!--minNumber) {
                return true;
            }
        }
    }
    return false;
}

/**
 * Use to display store errors on the console:
 * Ext.create('Rally.data.lookback.SnapshotStore', {
 *      exceptionHandler: loggingSnapshotStoreExceptionHandler
 *      ...
 * });
 * @param proxy
 * @param response
 * @param operation
 */
function loggingSnapshotStoreExceptionHandler(proxy, response, operation) {
    var messages = JSON.parse(response.responseText);
    var log = function (message) {
        console.log(message);
    };
    console.log("Problem when obtaining snapshot data:");

    messages.Errors.forEach(log);
    messages.Warnings.forEach(log);

    console.log("proxy:", proxy, "response:", response, "operation:", operation);
}

function formatDate(date) {
    return Rally.util.DateTime.format((date instanceof Date) ? date : new Date(date), "dMy");
}

function dateToIsoString(date) {
    return date.toISOString().substring(0, 10);
}

function chainedExpression(operator, expressions) {
    var joined = expressions.filter(function (expression) {
        return !!expression;
    }).join(") " + operator + " (");
    return "((" + joined + "))";
}

function workItemQuery(data, condition) {
    var itemIDs = data.filter(function (item) {
        return item.data._ValidTo === "9999-01-01T00:00:00.000Z";
    }).filter(condition).map(function (item) {
        return "ObjectID = " + item.data.ObjectID;
    });
    return itemIDs.length > 0 ? chainedExpression("OR", itemIDs) : "* no such items *";
}

function isUserStory(item) {
    return item.data.FormattedID.indexOf("US") === 0;
}

function isDefect(item) {
    return item.data.FormattedID.indexOf("DE") === 0;
}

function isAccepted(item) {
    return item.data.ScheduleState === "Accepted" || item.data.ScheduleState === "Released-to-Production";
}

function addBusinessDays(date, businessDays) {
    var result = new Date(date);
    if (businessDays) {
        var oldTimezoneOffset = result.getTimezoneOffset();
        var days = result.getDate();
        var dayOfMonth = result.getDay();
        var step = businessDays > 0 ? 1 : -1;
        var weekDayStep = businessDays > 0 ? 1 : 6;
        while (businessDays !== 0) {
            days += step;
            dayOfMonth = (dayOfMonth + weekDayStep) % 7;
            if (dayOfMonth !== 0 && dayOfMonth !== 6) {
                businessDays -= step;
            }
        }
        result.setDate(days);
        var offsetDiff = result.getTimezoneOffset() - oldTimezoneOffset;
        if (offsetDiff !== 0) {
            result.setTime(result.getTime() - offsetDiff * 60000);
        }
    }
    return result;
}

function lastBusinessDay(date) {
    var weekDay = new Date(date).getDay();
    return weekDay > 0 && weekDay < 6 ? date : lastBusinessDay(addBusinessDays(date, -1));
}

function parseCapacityPlan(capacityPlanDefinition) {
    if (!capacityPlanDefinition) {
        return null;
    }
    var capacityPlanString = capacityPlanDefinition.toString().trim();
    if (!capacityPlanString) {
        return null;
    }
    var parts = ("1970-01-01 " + capacityPlanString).split(/\s+/);
    var date, previousDate = new Date(-1);
    var capacityPlan = {
        dates: [],
        values: []
    };
    for (var dateIndex = 0, capacityIndex = 1; capacityIndex < parts.length; dateIndex += 2, capacityIndex += 2) {
        date = new Date(parts[dateIndex]);
        if (!parts[dateIndex].match(/^\d\d\d\d-\d\d?-\d\d?$/) || isNaN(date.getTime())) {
            throw "'" + parts[dateIndex] + "' found when a date was expected. The expected format is YYYY-MM-DD";
        }
        if (previousDate >= date) {
            throw "Invalid date: '" + dateToIsoString(date) + "'. It must be greater than '" + dateToIsoString(previousDate) + "'";
        }
        previousDate = date;
        var capacity = parseFloat(parts[capacityIndex]);
        if (!parts[capacityIndex].match(/^[+\-]?(\d*(\.\d+)|\d+)$/) || isNaN(capacity)) {
            throw "'" + parts[capacityIndex] + "' found when a capacity value was expected. It must be a number";
        }
        if (capacity < 0) {
            throw "'" + parts[capacityIndex] + "' found when a capacity value was expected. It must be a positive number";
        }
        capacityPlan.dates.push(dateToIsoString(date));
        capacityPlan.values.push(capacity);
    }
    if (capacityIndex === parts.length) {
        throw "Unexpected value at the end: '" + parts[dateIndex] + "'. Capacity Plan definition must end with a capacity value preceeded by a date";
    }
    capacityPlan.dates.push(dateToIsoString(new Date(9999999999999)));
    return capacityPlan;
}

function createLogger(milestones, portfolioItems, tags, project, fetchFields) {
    return function (store, data, success) {
        var label = "***** DEBUG INFO for MILESTONE BURNUP " + milestones.map(function (milestone) {
                return "<> " + milestone.get("Name");
            }).join(", ");
        if (portfolioItems) {
            label += ": " + portfolioItems.map(function (milestone) {
                    return milestone.get("FormattedID");
                }).join(", ");
        }
        if (tags.length > 0) {
            label += " [" + tags.join("][") + "]";
        }
        label += " - " + project.get("Name") + " ***** ";
        var log = function (title, content) {
            console.debug(label + title + ":");
            console.debug(content);
            console.debug();
        };
        log("DATA SNAPSHOTS", storeDataToString(data, fetchFields));
        log("Query for ALL STORIES", workItemQuery(data, function (item) {
            return isUserStory(item);
        }));
        log("Query for ALL DEFECTS", workItemQuery(data, function (item) {
            return isDefect(item);
        }));
        log("Query for NOT YET ACCEPTED STORIES", workItemQuery(data, function (item) {
            return isUserStory(item) && !isAccepted(item);
        }));
        log("Query for NOT YET ACCEPTED DEFECTS", workItemQuery(data, function (item) {
            return isDefect(item) && !isAccepted(item);
        }));
    };
}

function filterOutUnwantedPortfolioItems(ids, items) {
    return items.filter(function (item) {
        return ids.indexOf(item.get("FormattedID")) !== -1;
    });
}

                Ext.define("My.BurnUpCalculation", {

    /**
     * @param {Object} config
     * @param {Object} data
     {
         series: [
             {name: "Scope", data: [12, 14, 14, 15, ...] }, ...
         ],
         categories: ["2016-03-28", "2016-03-29", ...]
     }
     * @ {Object} chartConfig
     */
    calculate: function (data, config) {
        this.calcConfig = {
            today: config.today || new Date(),
            maxEndDate: config.maxEndDate,
            iteration: config.iteration,
            capacityPlan: config.capacityPlan,
            auxDates: config.auxDates,
            drawIterations: config.drawIterations,
            targetDate: config.targetDate,
            customStartDate: config.customStartDate,
            maxDaysAfterTargetDate: config.maxDaysAfterTargetDate,
            hideProjectedDateOutOfRange: config.hideProjectedDateOutOfRange,
            customTrendStartDate: config.customTrendStartDate,
            displayWidth: config.displayWidth
        };

        var tooltipStructure = {
            "Scope": {position: 0},
            "Not Started": {position: 1},
            "In Progress": {position: 2},
            "Completed": {position: 3},
            "Accepted": {position: 4}
        };
        var capacityProvider = {
            capacity: function (index) {
                return this.projectionCalculator.capacityPlan ? this.projectionCalculator.stepWeight(index) : null;
            },
            idealBurnUp: function (index) {
                return this.idealSeries && this.idealSeries[index - 1] && this.idealSeries[index] ? this.idealSeries[index] - this.idealSeries[index - 1] : null;
            }
        };
        this.capacityProvider = capacityProvider;

        this.chartConfig = {
            xAxis: {
                plotLines: []
            },
            yAxis: {},
            subtitle: {
                useHTML: true
            },
            tooltip: {
                formatter: function () {
                    var model = {
                        categories: [],
                        get: function (series) {
                            return model.categories[tooltipStructure[series].position];
                        },
                        set: function (series, object) {
                            model.categories[tooltipStructure[series].position] = object;
                        }
                    };
                    this.points.forEach(function (p) {
                        model.set(p.series.name, {value: p.y, name: p.series.name, color: p.series.color});
                    });
                    if (model.get("Scope")) {
                        if (model.get("In Progress") && model.get("Completed") && model.get("Accepted")) {
                            model.set("Not Started", {
                                value: model.get("Scope").value - model.get("In Progress").value - model.get("Completed").value - model.get("Accepted").value,
                                name: "Not Started",
                                color: "#CFCFCF"
                            });
                        }
                    }
                    model.categories.forEach(function (category) {
                        category.valueWholePart = Math.floor(category.value);
                        category.valueDecimalPart = Math.floor(Math.round((category.value - category.valueWholePart) * 10));
                        if (category.valueDecimalPart) {
                            model.isValueDecimalPart = true;
                        }
                        if (model.get("Scope")) {
                            var perMil = Math.round(category.value / model.get("Scope").value * 1000);
                            var percentWholePart = Math.floor(perMil / 10);
                            category.percent = percentWholePart + "." + Math.floor(Math.round((perMil - percentWholePart * 10))) + "%";
                        }
                    });
                    var tooltip = "<table style='border-spacing: 1ex 0; width: 100%'><caption style='padding-bottom: 0.4em'>" + this.x + "</caption>";
                    model.categories.forEach(function (category) {
                        if (category.value > 0) {
                            var valueHTML = category.valueWholePart + (model.isValueDecimalPart ? "." + category.valueDecimalPart : "");
                            tooltip += "<tr>" +
                                "<td style='color:" + category.color + "'>" + category.name + ":</td>" +
                                "<td style='font-weight: bold; text-align: right'>" + valueHTML + "</td>" +
                                (category.percent ? "<td style='text-align: right'>" + category.percent + "</td>" : "") +
                                "</tr>";
                        }
                    });
                    tooltip += "</table>";
                    var footer = [];
                    var index = this.points[0].point.x;
                    var capacity = capacityProvider.capacity(index);
                    if (capacity !== null) {
                        footer.push("Planned capacity: " + capacity);
                    }
                    var velocity = capacityProvider.idealBurnUp(index);
                    if (velocity !== null) {
                        footer.push("Ideal burnup: <b>" + velocity.toFixed(2) + "</b>");
                    }
                    if (footer) {
                        tooltip += "<div style='padding-top: 0.8em; text-align: center; font-size: 0.9em'>" + footer.join("<br/>") + "</div>";
                    }
                    return tooltip;
                },
                useHTML: true,
                shared: true
            }
        };

        this.adjustChartStart(data);
        this.stripFutureBars(data);
        this.addTrendLinesAndSubtitle(data);
        this.adjustDataAndChartConfig(data);

        return this.chartConfig;
    },

    adjustChartStart: function (data) {
        var firstInProgressIndex = this.findDateIndex(data.categories, lastBusinessDay(this.calcConfig.today), false, data.categories.length);
        data.series.forEach(function (series) {
            if (series.name !== "Scope") {
                for (var i = 0; i < series.data.length; i++) {
                    if (series.data[i] > 0 && i < firstInProgressIndex) {
                        firstInProgressIndex = i;
                        break;
                    }
                }
            }
        });
        var startIndex = this.calcConfig.customStartDate ? this.findDateIndex(data.categories, this.calcConfig.customStartDate, false, 0) : firstInProgressIndex;
        data.series.forEach(function (series) {
            series.data = series.data.slice(startIndex);
        });
        data.categories = data.categories.slice(startIndex);
    },

    stripFutureBars: function (data) {
        var currentIndex = this.findDateIndex(data.categories, this.calcConfig.today, false, data.categories.length) + 1;
        data.series.forEach(function (series) {
            if (series.name !== "Scope") {
                for (var i = currentIndex; i < series.data.length; i++) {
                    series.data[i] = null;
                }
            }
        });
    },

    addVerticalLine: function (label, index, config) {
        if (index === -1) {
            return;
        }
        var plotLines = this.chartConfig.xAxis.plotLines;
        for (var i = 0; i < plotLines.length; i++) {
            if (plotLines[i].value === index) {
                label = plotLines[i].label.text + " / " + label;
                plotLines.splice(i, 1);
            }
        }
        plotLines.push(Ext.merge(
            {label: {text: label, y: 3, x: 3, useHTML: true}, value: index, width: 2, color: "#000", zIndex: 5},
            config
        ));
    },

    addSeriesLine: function (data, name, series, config) {
        if (series) {
            data.series.push(Ext.merge(
                {name: name, data: series, type: "line", marker: {enabled: false}, enableMouseTracking: false, lineWidth: 1},
                config
            ));
        }
    },

    addSubtitleText: function (text) {
        var subtitle = this.chartConfig.subtitle;
        subtitle.text = subtitle.text ? subtitle.text + " &nbsp;&nbsp;&nbsp; " + text : text;
    },

    addTrendLinesAndSubtitle: function (data) {
        var config = this.calcConfig;
        var acceptedData = this.getSeriesData(data, "Accepted");
        var plannedData = this.getSeriesData(data, "Scope");
        var dates = data.categories;
        var todayIndex = this.findDateIndex(dates, config.today);
        var targetDateIndex = this.findDateIndex(dates, this.calcConfig.targetDate);
        var todayAcceptedPoints = acceptedData[todayIndex];
        var todayPlannedPoints = plannedData[todayIndex];
        var projectionStart = this.getTrendStart(dates, acceptedData);
        var trendSeries;
        var completedIndex;
        var projectionCalculator = this.createProjectionCalculator({
            capacityPlan: this.calcConfig.capacityPlan,
            projectionStart: projectionStart,
            firstDate: dates[0]
        });
        this.capacityProvider.projectionCalculator = projectionCalculator;
        if (this.calcConfig.targetDate) {
            var idealSeries = projectionCalculator.projectionSeries(targetDateIndex, plannedData[targetDateIndex], targetDateIndex);
            this.capacityProvider.idealSeries = idealSeries;
            this.addSeriesLine(data, "Ideal", idealSeries, {dashStyle: "Dot"});
            this.addSubtitleText("Target Date" + ": " + formatDate(this.calcConfig.targetDate));
        }
        var trendControlIndex = todayIndex;
        // when scope completed
        if (todayAcceptedPoints === todayPlannedPoints && todayPlannedPoints > 0) {
            var k = trendControlIndex - 1;
            while (acceptedData[k] === todayPlannedPoints || acceptedData[k] === null && plannedData[k] === todayPlannedPoints) {
                trendControlIndex--;
                k--;
            }
            completedIndex = trendControlIndex;
        } else {
            var lastIndex = dates.length - 1;
            var lastPlannedPoints = plannedData[lastIndex];
            if (acceptedData[lastIndex] === lastPlannedPoints && lastPlannedPoints > 0) {
                completedIndex = lastIndex;
                var l = lastIndex - 1;
                while (acceptedData[l] === lastPlannedPoints || acceptedData[l] === null && plannedData[l] === lastPlannedPoints) {
                    completedIndex--;
                    l--;
                }
            }
        }
        var projectedDateIndex;
        var maxIndex;
        if (trendControlIndex !== -1) {
            var maxDaysAfterTargetDate = this.calcConfig.maxDaysAfterTargetDate || 0;
            maxIndex = Math.max(todayIndex, (targetDateIndex === -1 ? trendControlIndex : targetDateIndex) + maxDaysAfterTargetDate);
            // draw trend
            var trendFactor = projectionCalculator.projectionFactor(trendControlIndex, todayAcceptedPoints, Infinity, todayPlannedPoints);
            if (trendFactor !== Infinity) {
                trendSeries = projectionCalculator.projectionSeries(trendControlIndex, todayAcceptedPoints, Infinity, todayPlannedPoints);
                if (trendSeries) {
                    this.addSeriesLine(data, "Trend", trendSeries.slice(0, maxIndex + 1), {dashStyle: "Dash"});
                    projectedDateIndex = trendSeries.length - 1;
                    this.projectedEndDate = addBusinessDays(new Date(dates[0]), projectedDateIndex);
                    if (!completedIndex && this.projectedEndDate) {
                        if (!this.calcConfig.hideProjectedDateOutOfRange || projectedDateIndex <= maxIndex) {
                            this.addSubtitleText("Projected Date" + ": " + formatDate(this.projectedEndDate));
                        }
                    }
                }
            }
            // expand categories and scope line beyond today
            for (var j = Math.max(todayIndex, targetDateIndex, dates.length - 1); j < maxIndex; j++) {
                plannedData.push(todayPlannedPoints);
                dates.push(dateToIsoString(addBusinessDays(new Date(dates[dates.length - 1]), 1)));
            }
        }
        var spliceIndex;
        var deleteCount = dates.length;
        if (completedIndex) {
            // do not display completed columns after target date
            spliceIndex = Math.max(completedIndex, targetDateIndex) + 1;
            dates.splice(spliceIndex, deleteCount);
            acceptedData.splice(spliceIndex, deleteCount);
            plannedData.splice(spliceIndex, deleteCount);
            this.getSeriesData(data, "In Progress").splice(spliceIndex, deleteCount);
            this.getSeriesData(data, "Completed").splice(spliceIndex, deleteCount);
            this.addSubtitleText("Accepted" + ": " + formatDate(dates[completedIndex]));
        } else {
            // truncate not interesting data from the right
            var ifEmpty = function (index, ifEmpty) {
                return index === -1 || index === null || index === undefined ? ifEmpty : index;
            };
            spliceIndex = Math.max(ifEmpty(todayIndex, 0), ifEmpty(targetDateIndex, 0), Math.min(ifEmpty(projectedDateIndex, null), ifEmpty(maxIndex, null))) + 1;
            if (spliceIndex) {
                dates.splice(spliceIndex, deleteCount);
                plannedData.splice(spliceIndex, deleteCount);
            }
        }
        this.addPlotLines(dates, projectedDateIndex, completedIndex);
        // ignore too big historical scope for better readability of the chart
        var maxPlannedPoints = plannedData.reduce(function (e, max) {
            return e > max ? e : max;
        }, 0);
        var yMax = todayPlannedPoints * 1.3;
        if (maxPlannedPoints > yMax) {
            this.chartConfig.yAxis.max = yMax;
        }
        if (config.drawIterations) {
            this.addIterationsBands(dates);
        }
    },

    addPlotLines: function (dates, projectedEndIndex, completedIndex) {
        var config = this.calcConfig;
        if (config.auxDates && hasOwnProperties(config.auxDates, 1)) {
            for (var auxDate in config.auxDates) {
                if (config.auxDates.hasOwnProperty(auxDate)) {
                    this.addVerticalLine(config.auxDates[auxDate], this.findDateIndex(dates, auxDate, true), {width: 1, label: {x: 2}});
                }
            }
        }
        this.addVerticalLine("Today", this.findDateIndex(dates, config.today, true), {color: "#AAA", dashStyle: "ShortDash"});
        this.addVerticalLine("Target Date", this.findDateIndex(dates, config.targetDate, true));
        if (completedIndex) {
            this.addVerticalLine("Accepted", completedIndex, {color: "#774"});
        } else if (projectedEndIndex) {
            this.addVerticalLine("Projected Date", projectedEndIndex, {dashStyle: "ShortDash"});
        }
    },

    addIterationsBands: function (dates) {
        var config = this.calcConfig;
        var iterationStartDate = config.iteration.get("StartDate");
        var iterationEndDate = config.iteration.get("EndDate");
        var iterationDuration = 0;
        var date = iterationStartDate;
        while (date < iterationEndDate) {
            date = addBusinessDays(date, 1);
            iterationDuration++;
        }
        var band = true;
        var startDate = iterationStartDate;
        while (dateToIsoString(startDate) > dates[0]) {
            startDate = addBusinessDays(startDate, -iterationDuration);
            band = !band;
        }
        do {
            startDate = addBusinessDays(startDate, iterationDuration);
            band = !band;
        } while (dateToIsoString(startDate) < dates[0]);

        var startIndex = this.findDateIndex(dates, startDate);
        if (startIndex === -1) {
            return;
        }

        var color = "#F8F9FD";
        this.chartConfig.xAxis.plotBands = [];
        var i = startIndex - (band ? iterationDuration : 0);
        do {
            this.chartConfig.xAxis.plotBands.push({color: color, from: Math.max(0, i), to: i + iterationDuration});
            i += iterationDuration * 2;
        } while (i < dates.length);
    },


    getTrendStart: function (dates, acceptedData) {
        var index;
        if (this.calcConfig.customTrendStartDate) {
            index = this.findDateIndex(dates, this.calcConfig.customTrendStartDate, false, 0);
        } else {
            for (index = 0; index < acceptedData.length; index++) {
                if (acceptedData[index] > 0) {
                    break;
                }
            }
        }
        return {index: index, value: acceptedData[index] || 0};
    },

    findDateIndex: function (dates, date, floating, defaultIndex) {
        var searchedDateString = (date instanceof Date) ? dateToIsoString(date) : date;
        if (dates.length > 0 && dates[0] <= searchedDateString) {
            for (var i = 0; i < dates.length; i++) {
                var dateString = dates[i];
                if (dateString >= searchedDateString) {
                    return dateString > searchedDateString ? i - (floating ? 0.5 : 1) : i;
                }
            }
        }
        return defaultIndex || defaultIndex === 0 ? defaultIndex : -1;
    },

    getSeriesData: function (data, name) {
        for (var i = 0; i < data.series.length; i++) {
            var s = data.series[i];
            if (s.name === name) {
                return s.data;
            }
        }
        return [];
    },

    adjustDataAndChartConfig: function (data) {
        data.categories = data.categories.map(function (date) {
            return formatDate(date);
        });
        var displayWidth = Math.max(Math.min(+this.calcConfig.displayWidth || 100, 500), 10);
        var threshold = data.categories.length * (100 / displayWidth);
        var step, lineWidth, groupPadding, markerEnabled;
        if (threshold > 360) {
            groupPadding = 0;
            lineWidth = 3;
            step = 30;
        } else if (threshold > 240) {
            groupPadding = 0.05;
            lineWidth = 3;
            step = 20;
        } else if (threshold > 120) {
            groupPadding = 0.1;
            lineWidth = 3;
            step = 10;
        } else {
            groupPadding = 0.15;
            markerEnabled = true;
            lineWidth = 3;
            step = 5;
        }
        Ext.merge(this.chartConfig, {
            xAxis: {
                labels: {
                    step: step
                }
            },
            plotOptions: {
                line: {
                    marker: {enabled: markerEnabled},
                    lineWidth: lineWidth
                },
                column: {
                    groupPadding: groupPadding
                }
            }
        });
    },

    createProjectionCalculator: function (config) {
        return config.capacityPlan ?
            Ext.create("My.FlexProjectionCalculator", config) :
            Ext.create("My.FixedProjectionCalculator", config);
    }
});

Ext.define("My.FixedProjectionCalculator", {
    constructor: function (config) {
        this.callParent(arguments);
        this.startIndex = config.projectionStart.index;
        this.startValue = config.projectionStart.value;
    },

    projectionFactor: function (endIndex, endValue) {
        if (this.startIndex >= 0 && this.startIndex < endIndex && this.startValue !== endValue) {
            return this._projectionFactor(endIndex, endValue);
        } else {
            console.log("Unable to calculate trend step for values: (startIndex=" +
                this.startIndex + ", startValue=" + this.startValue + ", endIndex=" + endIndex + ", endValue=" + endValue + ")"
            );
            return null;
        }
    },

    projectionSeries: function (endIndex, endValue, indexLimit, valueLimit) {
        var projectionFactor = this.projectionFactor(endIndex, endValue);
        if (projectionFactor && projectionFactor > 0 && indexLimit !== 0) {
            var data = [];
            var i;
            for (i = 0; i < this.startIndex; i++) {
                data[i] = null;
            }
            data[i] = this.startValue;
            i++;
            var actualIndexLimit = indexLimit || Infinity;
            for (; i <= actualIndexLimit && (!valueLimit || data[i - 1] + 0.000000001 < valueLimit); i++) {
                data[i] = data[i - 1] + projectionFactor * this.stepWeight(i);
            }
            return data;
        } else {
            return null;
        }
    },

    stepWeight: function (index) {
        return 1;
    },

    _projectionFactor: function (endIndex, endValue) {
        return (endValue - this.startValue) / (endIndex - this.startIndex);
    }
});

Ext.define("My.FlexProjectionCalculator", {
    extend: "My.FixedProjectionCalculator",

    constructor: function (config) {
        this.callParent(arguments);
        this.capacity = [];
        this.capacityPlan = config.capacityPlan;
        this.capacityPlanCursor = 0;
        this.dateCursor = config.firstDate;
    },

    stepWeight: function (index) {
        if (this.capacity[index]) {
            return this.capacity[index];
        }
        for (var i = this.capacity.length; i <= index; i++) {
            if (this.dateCursor >= this.capacityPlan.dates[this.capacityPlanCursor + 1]) {
                this.capacityPlanCursor++;
            }
            this.capacity[i] = this.capacityPlan.values[this.capacityPlanCursor];
            this.dateCursor = dateToIsoString(addBusinessDays(this.dateCursor, 1));
        }
        return this.capacity[index];
    },

    _projectionFactor: function (endIndex, endValue) {
        var weightSum = 0;
        for (var i = this.startIndex + 1; i <= endIndex; i++) {
            weightSum += this.stepWeight(i);
        }
        return (endValue - this.startValue) / weightSum;
    }
});

                window.dev = window.dev || undefined;

Ext.define("MilestoneBurnupWithProjection", Ext.merge({
    extend: "Rally.app.App",
    componentCls: "app",

    setContextTimebox: function (timeboxScope) {
        this._timeboxFromScope = timeboxScope && timeboxScope.getRecord();
    },

    getContextTimebox: function () {
        if (!this._timeboxFromScope) {
            this.setContextTimebox(this.getContext().getTimeboxScope());
        }
        return this._timeboxFromScope;
    },

    getSettingsFields: function () {
        var milestones = this.getSetting("milestones");
        var defaultConfig = {width: 400, labelWidth: 210};
        var dateFieldConfig = Ext.merge(Ext.clone(defaultConfig), {format: "Y-m-d"});
        var checkboxConfig = {labelWidth: 380};
        var currentProjectText = "-- Current Project --";
        var contextTimebox = this.getContextTimebox();
        var settingsFields = [];
        settingsFields.push({ // be careful changing options here, this combo should allow no selection, one and multiple selections and storing previous state for all of these cases
            name: "milestones",
            label: "<abbr title='What do the chart bars and the Scope line mean?\n\n" +
            "Chart displays historical estimation (Plan Est) of stories and defects assigned to the specified milestone, aggregated by Schedule State.\n" +
            "Scope is the total estimate. Only leaf stories&apos; estimates count. Milestone assigned to a parent story or portfolio item is implicitly\n" +
            "propagated to the child items. Items that were assigned to the milestone in the past but no longer are, are not considered in the chart at all.'>Milestone(s)</abbr>",
            xtype: "rallymilestonecombobox",
            editable: true,
            multiSelect: true,
            allowNoEntry: true,
            emptyText: "-- Choose --",
            hideLabel: false,
            autoSelect: false,
            forceSelection: "string" != typeof milestones || milestones.indexOf(",") < 0 // workaround for a bug (?) in combo when multiple selection is not repopulated
        });

        settingsFields.push({html: "<h3>Additional options</h3>", xtype: "label"});

        /// filtering options ///
        settingsFields.push({
            name: "project",
            label: "Project",
            xtype: "rallyprojectcombobox", // this is private component but works for now and is much convenient than the public one
            allowBlank: true,
            allowClear: true,
            clearText: currentProjectText,
            emptyText: currentProjectText, // all those 4 allow/blank/cleat/text options are required for "Current project" option working smoothly for user
            listeners: {
                ready: function (comp) { // hack in validation to allow empty value meaning "Current project"
                    var originalValidator = comp.validator;
                    comp.validator = function (value) {
                        if (currentProjectText == value) {
                            value = "";
                            this.setValue(value);
                        }
                        return !value || originalValidator.call(this, value);
                    };
                }
            },
            config: defaultConfig
        });
        settingsFields.push({
            name: "teamFeatures",
            xtype: "textfield",
            label: "<abbr title='One or more IDs of Portfolio Items, of which story or defect\n" +
            "must be a direct or indirect child, for example:\n\n" +
            "TF12345, FEA1234, PRJ123, PGM12\n\n" +
            "For a Team Feature, you can omit the letter prefix (TF).'>Portfolio Items</abbr>:", config: defaultConfig
        });
        settingsFields.push({
            name: "tags",
            xtype: "textfield",
            label: "<abbr title='Comma separated list of tags. At least one must match. Tags are inherited from parents, like milestones.\n\n" +
            "Instead of assigning tags to the items in a normal way, you can use naming convention - include\n" +
            "keywords in square brackets in the item&apos;s name, for example: \"[integration] As a user, I...\".'>Tags</abbr>:",
            config: defaultConfig
        });

        /// plot options ///
        settingsFields.push({name: "customStartDate", xtype: "rallydatefield", label: "Ignore data until:", config: dateFieldConfig});
        settingsFields.push({name: "customTrendStartDate", xtype: "rallydatefield", label: "Start projection lines from:", config: dateFieldConfig});
        settingsFields.push({
            name: "maxDaysAfterTargetDate",
            xtype: "rallynumberfield",
            label: "Max days to show after Target Date",
            config: Ext.merge(Ext.clone(defaultConfig), {minValue: 0, maxValue: 250})
        });
        settingsFields.push({
            name: "capacityPlan",
            xtype: "textarea",
            label: "Model projection lines with a specific capacity plan (provide average daily capacity values separated by the dates when they change &ndash; <abbr title='" +
            "When the team capacity is 3 before September, in September 6 and 2.5 later:\n\n" +
            "3 2018-09-01 6 2018-10-01 2.5'>example</abbr>)",
            height: 70,
            config: defaultConfig
        });
        settingsFields.push({
            name: "markAuxDates",
            xtype: "rallycheckboxfield",
            label: "Mark additional key dates on the chart (such dates must be specified in the Milestone's Notes field &ndash; <abbr title='" +
            "When the Code Complete is on Dec 10 and RC Build is planned on Jan 15:\n\n" +
            "2018-12-10 Code Complete&#013;2019-01-15 RC Build'>example</abbr>)",
            config: checkboxConfig
        });

        /// display options ///
        settingsFields.push({
            name: "hideProjectedDateOutOfRange",
            xtype: "rallycheckboxfield",
            label: "Hide Projected Date in the subtitle when not visible on the chart",
            config: checkboxConfig
        });
        settingsFields.push({
            name: "drawIterations",
            xtype: "rallycheckboxfield",
            label: "Draw Iteration boundaries on chart's background",
            config: checkboxConfig
        });
        settingsFields.push({name: "showProjectName", xtype: "rallycheckboxfield", label: "Show Project name in the title", config: checkboxConfig});
        settingsFields.push({name: "projectTargetPage", xtype: "textfield", label: "Project name in the title links to:", config: defaultConfig});
        settingsFields.push({
            name: "displayWidth",
            xtype: "combobox",
            label: "Display width %, decrease it to fix chart look in a small display area",
            store: Ext.create('Ext.data.Store', {
                fields: ['value'],
                data: [{value: 100}, {value: 50}, {value: 30}]
            }),
            queryMode: "local",
            displayField: "value",
            valueField: "value",
            config: defaultConfig,
            validator: function (value) {
                if (isNaN(value)) {
                    return "Number expected";
                }
                var MIN = 10, MAX = 300;
                if (value < MIN || value > MAX) {
                    return "Value out of allowed range (" + MIN + "-" + MAX + ")";
                }
                return true;
            }
        });

        /// advanced options ///
        settingsFields.push({
            name: "debug",
            xtype: "rallycheckboxfield",
            label: "Debug mode (prints <abbr title='Use queries that are printed to the console together with the Custom List app (paste them into the Query settings field)\n" +
            "to identify which actual items (stories and defects) contribute to the chart. Note that such list is not dynamic\n" +
            "and it contains only the items matching the chart criteria from the moment it was generated.'>diagnostic data</abbr> in the JavaScript console)",
            config: checkboxConfig
        });
        return settingsFields;
    },

    config: {
        defaultSettings: {
            maxDaysAfterTargetDate: 45,
            markAuxDates: true,
            projectTargetPage: "iterationstatus",
            displayWidth: 100,
            drawIterations: true,
            showProjectName: true
        }
    },

    getMilestoneIds: function () {
        if (getRallyRecordType(this.getContextTimebox()) === "milestone") {
            return [this.getContextTimebox()];
        }
        var milestones = this.getSetting("milestones");
        return milestones ? milestones.split(",") : [];
    },

    getProjectId: function () {
        var project = this.getSetting("project");
        if (project) {
            return getRallyIdFromRef(project, "project");
        }
        return this.getContext().getProject().ObjectID;
    },

    getPortfolioItemIds: function () {
        var portfolioItems = this.getSetting("teamFeatures");
        if (!portfolioItems) {
            return [];
        }
        return portfolioItems.toString().split(/\s*[,;\s]\s*/).filter(function (id) {
            return id !== "";
        }).map(function (id) {
            return id.match(/^\d+$/) ? "TF" + id : id.toUpperCase();
        });
    },

    getTags: function () {
        var tags = this.getSetting("tags");
        if (!tags) {
            return [];
        }
        return tags.toString().split(/\s*[,;]\s*/).filter(function (tag) {
            return tag !== "";
        });
    },

    setDataLoading: function (loading) {
        this.setLoading(this.dataLoaded ? false : loading);
    },

    setDataLoaded: function (loaded) {
        this.dataLoaded = loaded;
        this.setLoading(false);
    },

    layout: "fit",

    // main
    launch: function () {
        this.getDataForChart().then({
            success: function (chartSetup) {
                this.add(Ext.merge(this.createChart(), chartSetup));
            },
            failure: function (error) {
                this.setDataLoaded();
                var lines = ["Unable to fetch data."];
                if (error && error.error && error.error.errors) {
                    lines = lines.concat(error.error.errors);
                } else {
                    lines.push(error);
                }
                this.add({itemId: "chart", xtype: "container", html: lines.join("<br/>"), componentCls: "center"});
            },
            scope: this
        });
    },

    onTimeboxScopeChange: function (timeboxScope) {
        var timebox = timeboxScope.getRecord();
        var timeboxType = getRallyRecordType(timebox);
        if (timeboxType === "milestone") {
            this.setContextTimebox(timeboxScope);
            var settings = {milestones: [timebox.get("_ref")]};
            Rally.data.PreferenceManager.update({
                appID: this.getAppId(),
                settings: settings
            });
            this.remove("chart");
            this.setDataLoaded(false);
            this.launch();
        }
    },

    listeners: {
        boxready: function (app) {
            app.setDataLoading(true);
        },

        ready: function (app) {
            app.defineCalculator();
        }
    },

    defineCalculator: function () {
        function metric(label, values) {
            return {
                as: label,
                f: "filteredSum",
                field: "PlanEstimate",
                filterField: "ScheduleState",
                filterValues: values,
                display: "column"
            };
        }

        Ext.define("My.MilestoneBurnUpCalculator", {
            extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",
            mixins: ["My.BurnUpCalculation"],

            getMetrics: function () {
                return [
                    metric("In Progress", ["In-Progress"]),
                    metric("Completed", ["Completed"]),
                    metric("Accepted", ["Accepted", "Released-to-Production"]),
                    {as: "Scope", f: "sum", field: "PlanEstimate", display: "line"}
                ];
            },

            runCalculation: function (snapshots, snapshotsToSubtract) {
                var data = this.callParent(arguments);
                this.chartConfig = this.calculate(data, this.calculationConfig);
                return data;
            }
        });
    },

    createChart: function () {
        var app = this;
        return Ext.create("Rally.ui.chart.Chart", {
            itemId: "chart",
            chartColors: ["#B4F4D9", "#9FDDA7", "#6DBD44", app.scopeColor, "#000", "#000"], // in progress, completed, accepted, planned, trend, ideal
            chartConfig: {
                title: {text: "Milestone"},
                chart: {zoomType: "xy"},
                xAxis: {
                    title: {text: "Date"},
                    labels: {
                        maxStaggerLines: 1,
                        step: 5
                    }
                },
                yAxis: {
                    title: {text: "Points"},
                    minRange: 10,
                    min: 0
                },
                plotOptions: {
                    line: {
                        marker: {enabled: false},
                        lineWidth: 4
                    },
                    column: {
                        pointPadding: 0,
                        stacking: true
                    },
                    area: {
                        stacking: true,
                        marker: {enabled: false}
                    }
                }
            },

            listeners: {
                snapshotsAggregated: function (chart) {
                    Ext.merge(chart.chartConfig, chart.calculator.chartConfig);
                },

                storesLoaded: function () {
                    app.setLoading(false);
                }
            }
        });
    },

    getDataForChart: function () {
        var portfolioItemIds = this.getPortfolioItemIds();
        var tags = this.getTags();
        return promiseAll([
            !this.getProjectId() ? this.getProjectId() : Rally.data.ModelFactory.getModel({type: "Project"}).then({
                success: function (model) {
                    return model.load(this.getProjectId());
                },
                scope: this
            }),
            Ext.create("Rally.data.wsapi.Store", {
                model: "Iteration",
                fetch: ["StartDate", "EndDate"],
                filters: Rally.data.wsapi.Filter.fromQueryString("((StartDate <= today) AND (EndDate >= today))")
            }).load(),
            this.getMilestoneIds().length === 0 ? [] : Rally.data.ModelFactory.getModel({type: "Milestone"}).then({
                success: function (model) {
                    return promiseAll(this.getMilestoneIds().map(function (id) {
                        return model.load(id);
                    }));
                },
                scope: this
            }),
            portfolioItemIds.length === 0 ? [] : Ext.create("Rally.data.wsapi.Store", {
                model: "PortfolioItem",
                filters: Rally.data.wsapi.Filter.fromQueryString(chainedExpression("OR", portfolioItemIds.map(function (id) {
                    return "FormattedID = " + id;
                }))),
                scope: this,
                context: {
                    projectScopeUp: true
                }
            }).load()
        ]).then({
            success: function (contextItems) {
                try {
                    this.capacityPlan = parseCapacityPlan(this.getSetting("capacityPlan"));
                } catch (error) {
                    return rejectedPromise("The following problem found in the Capacity Plan definition: <p>" + error + "</p>. " +
                        "Please correct the app settings:<pre>" + this.getSetting("capacityPlan") + "</pre>");
                }
                this.project = contextItems[0];
                this.iteration = contextItems[1][0];

                var milestones = contextItems[2];
                this.ensureColorsForMilestones(milestones);
                if (milestones.length === 0) {
                    return rejectedPromise("No milestone specified. Set milestone filter in your page settings or choose milestone in the app settings.");
                }

                this.portfolioItems = filterOutUnwantedPortfolioItems(this.getPortfolioItemIds(), contextItems[3]);
                if (this.portfolioItems.length === 0 && portfolioItemIds.length > 0) {
                    return rejectedPromise("None of the Portfolio Items specified in the app settings: <p>" + portfolioItemIds.join(", ") + "</p>, " +
                        "exist in this project. Please correct the app settings or change the project.");
                }

                var loadParentsByMilestone = this.loadParentItems(chainedExpression("OR", milestones.map(function (milestone) {
                    return "Milestones.ObjectID contains " + milestone.getId();
                })));

                var loadParentsByTags = tags.length === 0 ? [] : this.loadParentItems(chainedExpression("OR", tags.map(function (tag) {
                    return "(Tags.Name = \"" + tag + "\") OR (Name contains \"[" + tag + "]\")";
                })));

                return promiseAll(
                    [loadParentsByMilestone, loadParentsByTags]
                ).then({
                    success: function (results) {
                        var parentIdsByMilestone = collectIds([].concat.apply([], results[0]));
                        var parentIdsByTag = collectIds([].concat.apply([], results[1]));
                        return this.getConfigForChart(parentIdsByMilestone, milestones, parentIdsByTag, tags, this.portfolioItems, this.project);
                    },
                    scope: this
                });
            },
            scope: this
        });
    },

    loadParentItems: function (query) {
        var context = {projectScopeUp: true};
        return promiseAll(["PortfolioItem", "HierarchicalRequirement", "Defect"].map(function (artifactType) {
            return Ext.create('Rally.data.wsapi.Store', {
                model: artifactType,
                filters: Rally.data.wsapi.Filter.fromQueryString(query),
                fetch: ["ObjectID", "Milestones", "Parent", "PortfolioItem"],
                context: context,
                autoLoad: true,
                limit: Infinity
            }).load();
        }));
    },

    getConfigForChart: function (parentIdsByMilestone, milestones, parentIdsByTag, tags, portfolioItems, project) {
        var portfolioItemIds = collectIds(portfolioItems);
        var query = {
            _ProjectHierarchy: this.projectId,
            $and: [
                {_ItemHierarchy: {$in: parentIdsByMilestone}}
            ],
            _TypeHierarchy: {$in: ["Defect", "HierarchicalRequirement"]},
            Children: null
        };
        if (portfolioItemIds.length > 0) {
            query.$and.push({_ItemHierarchy: {$in: portfolioItemIds}});
        }
        if (parentIdsByTag.length > 0) {
            query.$and.push({_ItemHierarchy: {$in: parentIdsByTag}});
        }
        var fetchFields = ["_ValidFrom", "_ValidTo", "ObjectID", "FormattedID", "PlanEstimate", "ScheduleState"];
        var debug = this.getSetting("debug");
        var storeConfig = {
            find: query,
            fetch: fetchFields,
            hydrate: ["ScheduleState"],
            compress: true,
            sort: {_ValidFrom: 1}, // 1 = ASC
            limit: Infinity,
            removeUnauthorizedSnapshots: true,
            useHttpPost: true
        };
        if (debug) {
            storeConfig.listeners = {load: createLogger(milestones, portfolioItems, tags, project, fetchFields)};
        }

        var lastWorkingDay = lastBusinessDay(new Date());
        var targetDate = this.getTargetDate(milestones);
        var maxDaysAfterTargetDate = this.getSetting("maxDaysAfterTargetDate");
        var endDate = targetDate;
        if (!targetDate) {
            endDate = lastWorkingDay;
        } else if (lastWorkingDay > targetDate) {
            var maxEndDate = addBusinessDays(targetDate, maxDaysAfterTargetDate);
            endDate = lastWorkingDay > maxEndDate ? lastWorkingDay : maxEndDate;
        }
        return {
            calculatorType: "My.MilestoneBurnUpCalculator",
            calculatorConfig: {
                endDate: endDate,
                calculationConfig: {
                    targetDate: targetDate,
                    iteration: this.iteration,
                    capacityPlan: this.capacityPlan,
                    auxDates: this.getAuxDates(milestones),
                    drawIterations: this.getSetting("drawIterations"),
                    customStartDate: this.getSetting("customStartDate"),
                    customTrendStartDate: this.getSetting("customTrendStartDate"),
                    maxDaysAfterTargetDate: maxDaysAfterTargetDate,
                    hideProjectedDateOutOfRange: this.getSetting("hideProjectedDateOutOfRange"),
                    displayWidth: this.getSetting("displayWidth")
                }
            },

            storeType: "Rally.data.lookback.SnapshotStore",
            storeConfig: storeConfig,

            exceptionHandler: loggingSnapshotStoreExceptionHandler,
            queryErrorMessage: "No work items found for <p>" + this.getChartTitle(milestones, tags, portfolioItems, true) + "</p>.",

            chartConfig: {
                title: {text: this.getChartTitle(milestones, tags, portfolioItems, false), useHTML: true}
            }
        };
    },

    ensureColorsForMilestones: function (milestones) {
        if (milestones) {
            milestones.forEach(function (milestone) {
                if (!milestone.get("DisplayColor")) {
                    milestone.set("DisplayColor", "#888888");
                }
            });
        }
    },


    getTargetDate: function (milestones) {
        var app = this;
        var latestMilestoneDate = null;
        milestones.forEach(function (milestone) {
            var date = milestone.get("TargetDate");
            if (!latestMilestoneDate || date && date > latestMilestoneDate) {
                latestMilestoneDate = date;
                app.scopeColor = milestone.get("DisplayColor");
            }
        });
        if (!app.scopeColor) {
            app.scopeColor = "#D42";
        }
        return latestMilestoneDate;
    },

    getAuxDates: function (milestones) {
        var result = {};
        var app = this;
        milestones.forEach(function (milestone) {
            if (app.getSetting("markAuxDates")) {
                milestone.get("Notes").split(/<\/?[^>]+>/g).map(function (html) {
                    return html.trim().match(/^(\d\d\d\d-\d\d?-\d\d?)\W+(\w.*)$/);
                }).forEach(function (matches) {
                    if (matches && !isNaN(Date.parse(matches[1]))) {
                        result[matches[1]] = matches[2].length <= 20 ? matches[2] : matches[2].substring(0, 20).trim() + "...";
                    }
                });
            }
            if (milestones.length > 1 && milestone.get("TargetDate")) {
                result[dateToIsoString(milestone.get("TargetDate"))] = milestoneIcon(milestone) + milestone.get("Name");
            }
        });
        return result;
    },

    getChartTitle: function (milestones, tags, portfolioItems, inlineDisplay) {
        var context = this.getContext();
        var title = milestones.map(function (milestone) {
            return formatMilestone(milestone, context);
        }).join(", ");
        if (portfolioItems.length > 0) {
            title += ": " + portfolioItems.map(function (portfolioItem) {
                    return formatPortfolioItem(portfolioItem, context);
                }).join(", ");
        }
        if (tags.length > 0) {
            console.log(tags);
            title += tags.map(function (tag) {
                return "<span style='background-color: #C4D8E8; border-radius: 3px; margin: 0 0 0 5px; padding: 0 4px; font-size: 90%'>" + tag + "</span>";
            }).join("");
        }
        if (this.getSetting("showProjectName")) {
            title += " &mdash; " + formatProject(this.project, this.getSetting("projectTargetPage"));
        }
        return inlineDisplay ? title : "<div style='margin-top: -5px; text-align: center'>" + title + "</div>";
    }
}, dev ? dev.app : null));


            Rally.launchApp('MilestoneBurnupWithProjection', {
                name:"Milestone Burnup with Projection",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .center {
  text-align: center;
}

    </style>
</head>
<body>
</body>
</html>
